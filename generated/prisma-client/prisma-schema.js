module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateConceptDatum {
  count: Int!
}

type AggregateInfoDemandTest {
  count: Int!
}

type AggregateInformationDemand {
  count: Int!
}

type AggregatePlatformMarketPrice {
  count: Int!
}

type AggregatePlatformSession {
  count: Int!
}

type AggregateRequestType {
  count: Int!
}

type AggregateTest {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ConceptDatum {
  data_id: Int!
  cellNum: String!
  dataKey: String!
  dataValue: String!
}

type ConceptDatumConnection {
  pageInfo: PageInfo!
  edges: [ConceptDatumEdge]!
  aggregate: AggregateConceptDatum!
}

input ConceptDatumCreateInput {
  data_id: Int
  cellNum: String!
  dataKey: String!
  dataValue: String!
}

type ConceptDatumEdge {
  node: ConceptDatum!
  cursor: String!
}

enum ConceptDatumOrderByInput {
  data_id_ASC
  data_id_DESC
  cellNum_ASC
  cellNum_DESC
  dataKey_ASC
  dataKey_DESC
  dataValue_ASC
  dataValue_DESC
}

type ConceptDatumPreviousValues {
  data_id: Int!
  cellNum: String!
  dataKey: String!
  dataValue: String!
}

type ConceptDatumSubscriptionPayload {
  mutation: MutationType!
  node: ConceptDatum
  updatedFields: [String!]
  previousValues: ConceptDatumPreviousValues
}

input ConceptDatumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConceptDatumWhereInput
  AND: [ConceptDatumSubscriptionWhereInput!]
  OR: [ConceptDatumSubscriptionWhereInput!]
  NOT: [ConceptDatumSubscriptionWhereInput!]
}

input ConceptDatumUpdateInput {
  cellNum: String
  dataKey: String
  dataValue: String
}

input ConceptDatumUpdateManyMutationInput {
  cellNum: String
  dataKey: String
  dataValue: String
}

input ConceptDatumWhereInput {
  data_id: Int
  data_id_not: Int
  data_id_in: [Int!]
  data_id_not_in: [Int!]
  data_id_lt: Int
  data_id_lte: Int
  data_id_gt: Int
  data_id_gte: Int
  cellNum: String
  cellNum_not: String
  cellNum_in: [String!]
  cellNum_not_in: [String!]
  cellNum_lt: String
  cellNum_lte: String
  cellNum_gt: String
  cellNum_gte: String
  cellNum_contains: String
  cellNum_not_contains: String
  cellNum_starts_with: String
  cellNum_not_starts_with: String
  cellNum_ends_with: String
  cellNum_not_ends_with: String
  dataKey: String
  dataKey_not: String
  dataKey_in: [String!]
  dataKey_not_in: [String!]
  dataKey_lt: String
  dataKey_lte: String
  dataKey_gt: String
  dataKey_gte: String
  dataKey_contains: String
  dataKey_not_contains: String
  dataKey_starts_with: String
  dataKey_not_starts_with: String
  dataKey_ends_with: String
  dataKey_not_ends_with: String
  dataValue: String
  dataValue_not: String
  dataValue_in: [String!]
  dataValue_not_in: [String!]
  dataValue_lt: String
  dataValue_lte: String
  dataValue_gt: String
  dataValue_gte: String
  dataValue_contains: String
  dataValue_not_contains: String
  dataValue_starts_with: String
  dataValue_not_starts_with: String
  dataValue_ends_with: String
  dataValue_not_ends_with: String
  AND: [ConceptDatumWhereInput!]
  OR: [ConceptDatumWhereInput!]
  NOT: [ConceptDatumWhereInput!]
}

input ConceptDatumWhereUniqueInput {
  data_id: Int
}

scalar DateTime

type InfoDemandTest {
  id: Int!
  platformSessionId: Int!
  requestId: Int!
  userId: Int!
}

type InfoDemandTestConnection {
  pageInfo: PageInfo!
  edges: [InfoDemandTestEdge]!
  aggregate: AggregateInfoDemandTest!
}

input InfoDemandTestCreateInput {
  id: Int
  platformSessionId: Int!
  requestId: Int!
  userId: Int!
}

type InfoDemandTestEdge {
  node: InfoDemandTest!
  cursor: String!
}

enum InfoDemandTestOrderByInput {
  id_ASC
  id_DESC
  platformSessionId_ASC
  platformSessionId_DESC
  requestId_ASC
  requestId_DESC
  userId_ASC
  userId_DESC
}

type InfoDemandTestPreviousValues {
  id: Int!
  platformSessionId: Int!
  requestId: Int!
  userId: Int!
}

type InfoDemandTestSubscriptionPayload {
  mutation: MutationType!
  node: InfoDemandTest
  updatedFields: [String!]
  previousValues: InfoDemandTestPreviousValues
}

input InfoDemandTestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InfoDemandTestWhereInput
  AND: [InfoDemandTestSubscriptionWhereInput!]
  OR: [InfoDemandTestSubscriptionWhereInput!]
  NOT: [InfoDemandTestSubscriptionWhereInput!]
}

input InfoDemandTestUpdateInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

input InfoDemandTestUpdateManyMutationInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

input InfoDemandTestWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  platformSessionId: Int
  platformSessionId_not: Int
  platformSessionId_in: [Int!]
  platformSessionId_not_in: [Int!]
  platformSessionId_lt: Int
  platformSessionId_lte: Int
  platformSessionId_gt: Int
  platformSessionId_gte: Int
  requestId: Int
  requestId_not: Int
  requestId_in: [Int!]
  requestId_not_in: [Int!]
  requestId_lt: Int
  requestId_lte: Int
  requestId_gt: Int
  requestId_gte: Int
  userId: Int
  userId_not: Int
  userId_in: [Int!]
  userId_not_in: [Int!]
  userId_lt: Int
  userId_lte: Int
  userId_gt: Int
  userId_gte: Int
  AND: [InfoDemandTestWhereInput!]
  OR: [InfoDemandTestWhereInput!]
  NOT: [InfoDemandTestWhereInput!]
}

input InfoDemandTestWhereUniqueInput {
  id: Int
}

type InformationDemand {
  id: Int!
  platformSessionId: Int!
  requestId: Int!
  userId: Int!
}

type InformationDemandConnection {
  pageInfo: PageInfo!
  edges: [InformationDemandEdge]!
  aggregate: AggregateInformationDemand!
}

input InformationDemandCreateInput {
  id: Int
  platformSessionId: Int!
  requestId: Int!
  userId: Int!
}

type InformationDemandEdge {
  node: InformationDemand!
  cursor: String!
}

enum InformationDemandOrderByInput {
  id_ASC
  id_DESC
  platformSessionId_ASC
  platformSessionId_DESC
  requestId_ASC
  requestId_DESC
  userId_ASC
  userId_DESC
}

type InformationDemandPreviousValues {
  id: Int!
  platformSessionId: Int!
  requestId: Int!
  userId: Int!
}

type InformationDemandSubscriptionPayload {
  mutation: MutationType!
  node: InformationDemand
  updatedFields: [String!]
  previousValues: InformationDemandPreviousValues
}

input InformationDemandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InformationDemandWhereInput
  AND: [InformationDemandSubscriptionWhereInput!]
  OR: [InformationDemandSubscriptionWhereInput!]
  NOT: [InformationDemandSubscriptionWhereInput!]
}

input InformationDemandUpdateInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

input InformationDemandUpdateManyMutationInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

input InformationDemandWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  platformSessionId: Int
  platformSessionId_not: Int
  platformSessionId_in: [Int!]
  platformSessionId_not_in: [Int!]
  platformSessionId_lt: Int
  platformSessionId_lte: Int
  platformSessionId_gt: Int
  platformSessionId_gte: Int
  requestId: Int
  requestId_not: Int
  requestId_in: [Int!]
  requestId_not_in: [Int!]
  requestId_lt: Int
  requestId_lte: Int
  requestId_gt: Int
  requestId_gte: Int
  userId: Int
  userId_not: Int
  userId_in: [Int!]
  userId_not_in: [Int!]
  userId_lt: Int
  userId_lte: Int
  userId_gt: Int
  userId_gte: Int
  AND: [InformationDemandWhereInput!]
  OR: [InformationDemandWhereInput!]
  NOT: [InformationDemandWhereInput!]
}

input InformationDemandWhereUniqueInput {
  id: Int
}

scalar Long

type Mutation {
  createConceptDatum(data: ConceptDatumCreateInput!): ConceptDatum!
  updateConceptDatum(data: ConceptDatumUpdateInput!, where: ConceptDatumWhereUniqueInput!): ConceptDatum
  updateManyConceptData(data: ConceptDatumUpdateManyMutationInput!, where: ConceptDatumWhereInput): BatchPayload!
  upsertConceptDatum(where: ConceptDatumWhereUniqueInput!, create: ConceptDatumCreateInput!, update: ConceptDatumUpdateInput!): ConceptDatum!
  deleteConceptDatum(where: ConceptDatumWhereUniqueInput!): ConceptDatum
  deleteManyConceptData(where: ConceptDatumWhereInput): BatchPayload!
  createInfoDemandTest(data: InfoDemandTestCreateInput!): InfoDemandTest!
  updateInfoDemandTest(data: InfoDemandTestUpdateInput!, where: InfoDemandTestWhereUniqueInput!): InfoDemandTest
  updateManyInfoDemandTests(data: InfoDemandTestUpdateManyMutationInput!, where: InfoDemandTestWhereInput): BatchPayload!
  upsertInfoDemandTest(where: InfoDemandTestWhereUniqueInput!, create: InfoDemandTestCreateInput!, update: InfoDemandTestUpdateInput!): InfoDemandTest!
  deleteInfoDemandTest(where: InfoDemandTestWhereUniqueInput!): InfoDemandTest
  deleteManyInfoDemandTests(where: InfoDemandTestWhereInput): BatchPayload!
  createInformationDemand(data: InformationDemandCreateInput!): InformationDemand!
  updateInformationDemand(data: InformationDemandUpdateInput!, where: InformationDemandWhereUniqueInput!): InformationDemand
  updateManyInformationDemands(data: InformationDemandUpdateManyMutationInput!, where: InformationDemandWhereInput): BatchPayload!
  upsertInformationDemand(where: InformationDemandWhereUniqueInput!, create: InformationDemandCreateInput!, update: InformationDemandUpdateInput!): InformationDemand!
  deleteInformationDemand(where: InformationDemandWhereUniqueInput!): InformationDemand
  deleteManyInformationDemands(where: InformationDemandWhereInput): BatchPayload!
  createPlatformMarketPrice(data: PlatformMarketPriceCreateInput!): PlatformMarketPrice!
  updatePlatformMarketPrice(data: PlatformMarketPriceUpdateInput!, where: PlatformMarketPriceWhereUniqueInput!): PlatformMarketPrice
  updateManyPlatformMarketPrices(data: PlatformMarketPriceUpdateManyMutationInput!, where: PlatformMarketPriceWhereInput): BatchPayload!
  upsertPlatformMarketPrice(where: PlatformMarketPriceWhereUniqueInput!, create: PlatformMarketPriceCreateInput!, update: PlatformMarketPriceUpdateInput!): PlatformMarketPrice!
  deletePlatformMarketPrice(where: PlatformMarketPriceWhereUniqueInput!): PlatformMarketPrice
  deleteManyPlatformMarketPrices(where: PlatformMarketPriceWhereInput): BatchPayload!
  createPlatformSession(data: PlatformSessionCreateInput!): PlatformSession!
  updatePlatformSession(data: PlatformSessionUpdateInput!, where: PlatformSessionWhereUniqueInput!): PlatformSession
  updateManyPlatformSessions(data: PlatformSessionUpdateManyMutationInput!, where: PlatformSessionWhereInput): BatchPayload!
  upsertPlatformSession(where: PlatformSessionWhereUniqueInput!, create: PlatformSessionCreateInput!, update: PlatformSessionUpdateInput!): PlatformSession!
  deletePlatformSession(where: PlatformSessionWhereUniqueInput!): PlatformSession
  deleteManyPlatformSessions(where: PlatformSessionWhereInput): BatchPayload!
  createRequestType(data: RequestTypeCreateInput!): RequestType!
  updateRequestType(data: RequestTypeUpdateInput!, where: RequestTypeWhereUniqueInput!): RequestType
  updateManyRequestTypes(data: RequestTypeUpdateManyMutationInput!, where: RequestTypeWhereInput): BatchPayload!
  upsertRequestType(where: RequestTypeWhereUniqueInput!, create: RequestTypeCreateInput!, update: RequestTypeUpdateInput!): RequestType!
  deleteRequestType(where: RequestTypeWhereUniqueInput!): RequestType
  deleteManyRequestTypes(where: RequestTypeWhereInput): BatchPayload!
  createTest(data: TestCreateInput!): Test!
  updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
  updateManyTests(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  upsertTest(where: TestWhereUniqueInput!, create: TestCreateInput!, update: TestUpdateInput!): Test!
  deleteTest(where: TestWhereUniqueInput!): Test
  deleteManyTests(where: TestWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PlatformMarketPrice {
  id: Int!
  active: Boolean!
  country: String!
  currency: String!
  date: DateTime!
  market: String!
  product: String!
  productAgg: String!
  productCat: String!
  retail: Int!
  source: String!
  udate: DateTime!
  unit: String!
  wholesale: Int!
}

type PlatformMarketPriceConnection {
  pageInfo: PageInfo!
  edges: [PlatformMarketPriceEdge]!
  aggregate: AggregatePlatformMarketPrice!
}

input PlatformMarketPriceCreateInput {
  id: Int
  active: Boolean
  country: String!
  currency: String!
  date: DateTime!
  market: String!
  product: String!
  productAgg: String!
  productCat: String!
  retail: Int!
  source: String!
  udate: DateTime
  unit: String!
  wholesale: Int!
}

type PlatformMarketPriceEdge {
  node: PlatformMarketPrice!
  cursor: String!
}

enum PlatformMarketPriceOrderByInput {
  id_ASC
  id_DESC
  active_ASC
  active_DESC
  country_ASC
  country_DESC
  currency_ASC
  currency_DESC
  date_ASC
  date_DESC
  market_ASC
  market_DESC
  product_ASC
  product_DESC
  productAgg_ASC
  productAgg_DESC
  productCat_ASC
  productCat_DESC
  retail_ASC
  retail_DESC
  source_ASC
  source_DESC
  udate_ASC
  udate_DESC
  unit_ASC
  unit_DESC
  wholesale_ASC
  wholesale_DESC
}

type PlatformMarketPricePreviousValues {
  id: Int!
  active: Boolean!
  country: String!
  currency: String!
  date: DateTime!
  market: String!
  product: String!
  productAgg: String!
  productCat: String!
  retail: Int!
  source: String!
  udate: DateTime!
  unit: String!
  wholesale: Int!
}

type PlatformMarketPriceSubscriptionPayload {
  mutation: MutationType!
  node: PlatformMarketPrice
  updatedFields: [String!]
  previousValues: PlatformMarketPricePreviousValues
}

input PlatformMarketPriceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlatformMarketPriceWhereInput
  AND: [PlatformMarketPriceSubscriptionWhereInput!]
  OR: [PlatformMarketPriceSubscriptionWhereInput!]
  NOT: [PlatformMarketPriceSubscriptionWhereInput!]
}

input PlatformMarketPriceUpdateInput {
  active: Boolean
  country: String
  currency: String
  date: DateTime
  market: String
  product: String
  productAgg: String
  productCat: String
  retail: Int
  source: String
  udate: DateTime
  unit: String
  wholesale: Int
}

input PlatformMarketPriceUpdateManyMutationInput {
  active: Boolean
  country: String
  currency: String
  date: DateTime
  market: String
  product: String
  productAgg: String
  productCat: String
  retail: Int
  source: String
  udate: DateTime
  unit: String
  wholesale: Int
}

input PlatformMarketPriceWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  active: Boolean
  active_not: Boolean
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  currency: String
  currency_not: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_lt: String
  currency_lte: String
  currency_gt: String
  currency_gte: String
  currency_contains: String
  currency_not_contains: String
  currency_starts_with: String
  currency_not_starts_with: String
  currency_ends_with: String
  currency_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  market: String
  market_not: String
  market_in: [String!]
  market_not_in: [String!]
  market_lt: String
  market_lte: String
  market_gt: String
  market_gte: String
  market_contains: String
  market_not_contains: String
  market_starts_with: String
  market_not_starts_with: String
  market_ends_with: String
  market_not_ends_with: String
  product: String
  product_not: String
  product_in: [String!]
  product_not_in: [String!]
  product_lt: String
  product_lte: String
  product_gt: String
  product_gte: String
  product_contains: String
  product_not_contains: String
  product_starts_with: String
  product_not_starts_with: String
  product_ends_with: String
  product_not_ends_with: String
  productAgg: String
  productAgg_not: String
  productAgg_in: [String!]
  productAgg_not_in: [String!]
  productAgg_lt: String
  productAgg_lte: String
  productAgg_gt: String
  productAgg_gte: String
  productAgg_contains: String
  productAgg_not_contains: String
  productAgg_starts_with: String
  productAgg_not_starts_with: String
  productAgg_ends_with: String
  productAgg_not_ends_with: String
  productCat: String
  productCat_not: String
  productCat_in: [String!]
  productCat_not_in: [String!]
  productCat_lt: String
  productCat_lte: String
  productCat_gt: String
  productCat_gte: String
  productCat_contains: String
  productCat_not_contains: String
  productCat_starts_with: String
  productCat_not_starts_with: String
  productCat_ends_with: String
  productCat_not_ends_with: String
  retail: Int
  retail_not: Int
  retail_in: [Int!]
  retail_not_in: [Int!]
  retail_lt: Int
  retail_lte: Int
  retail_gt: Int
  retail_gte: Int
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  udate: DateTime
  udate_not: DateTime
  udate_in: [DateTime!]
  udate_not_in: [DateTime!]
  udate_lt: DateTime
  udate_lte: DateTime
  udate_gt: DateTime
  udate_gte: DateTime
  unit: String
  unit_not: String
  unit_in: [String!]
  unit_not_in: [String!]
  unit_lt: String
  unit_lte: String
  unit_gt: String
  unit_gte: String
  unit_contains: String
  unit_not_contains: String
  unit_starts_with: String
  unit_not_starts_with: String
  unit_ends_with: String
  unit_not_ends_with: String
  wholesale: Int
  wholesale_not: Int
  wholesale_in: [Int!]
  wholesale_not_in: [Int!]
  wholesale_lt: Int
  wholesale_lte: Int
  wholesale_gt: Int
  wholesale_gte: Int
  AND: [PlatformMarketPriceWhereInput!]
  OR: [PlatformMarketPriceWhereInput!]
  NOT: [PlatformMarketPriceWhereInput!]
}

input PlatformMarketPriceWhereUniqueInput {
  id: Int
}

type PlatformSession {
  sess_id: Int!
  cellNum: String!
  createdDate: DateTime!
  data: String!
  notes: String!
  platformId: Int
  udate: DateTime!
}

type PlatformSessionConnection {
  pageInfo: PageInfo!
  edges: [PlatformSessionEdge]!
  aggregate: AggregatePlatformSession!
}

input PlatformSessionCreateInput {
  sess_id: Int
  cellNum: String!
  createdDate: DateTime!
  data: String!
  notes: String!
  platformId: Int
  udate: DateTime
}

type PlatformSessionEdge {
  node: PlatformSession!
  cursor: String!
}

enum PlatformSessionOrderByInput {
  sess_id_ASC
  sess_id_DESC
  cellNum_ASC
  cellNum_DESC
  createdDate_ASC
  createdDate_DESC
  data_ASC
  data_DESC
  notes_ASC
  notes_DESC
  platformId_ASC
  platformId_DESC
  udate_ASC
  udate_DESC
}

type PlatformSessionPreviousValues {
  sess_id: Int!
  cellNum: String!
  createdDate: DateTime!
  data: String!
  notes: String!
  platformId: Int
  udate: DateTime!
}

type PlatformSessionSubscriptionPayload {
  mutation: MutationType!
  node: PlatformSession
  updatedFields: [String!]
  previousValues: PlatformSessionPreviousValues
}

input PlatformSessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlatformSessionWhereInput
  AND: [PlatformSessionSubscriptionWhereInput!]
  OR: [PlatformSessionSubscriptionWhereInput!]
  NOT: [PlatformSessionSubscriptionWhereInput!]
}

input PlatformSessionUpdateInput {
  cellNum: String
  createdDate: DateTime
  data: String
  notes: String
  platformId: Int
  udate: DateTime
}

input PlatformSessionUpdateManyMutationInput {
  cellNum: String
  createdDate: DateTime
  data: String
  notes: String
  platformId: Int
  udate: DateTime
}

input PlatformSessionWhereInput {
  sess_id: Int
  sess_id_not: Int
  sess_id_in: [Int!]
  sess_id_not_in: [Int!]
  sess_id_lt: Int
  sess_id_lte: Int
  sess_id_gt: Int
  sess_id_gte: Int
  cellNum: String
  cellNum_not: String
  cellNum_in: [String!]
  cellNum_not_in: [String!]
  cellNum_lt: String
  cellNum_lte: String
  cellNum_gt: String
  cellNum_gte: String
  cellNum_contains: String
  cellNum_not_contains: String
  cellNum_starts_with: String
  cellNum_not_starts_with: String
  cellNum_ends_with: String
  cellNum_not_ends_with: String
  createdDate: DateTime
  createdDate_not: DateTime
  createdDate_in: [DateTime!]
  createdDate_not_in: [DateTime!]
  createdDate_lt: DateTime
  createdDate_lte: DateTime
  createdDate_gt: DateTime
  createdDate_gte: DateTime
  data: String
  data_not: String
  data_in: [String!]
  data_not_in: [String!]
  data_lt: String
  data_lte: String
  data_gt: String
  data_gte: String
  data_contains: String
  data_not_contains: String
  data_starts_with: String
  data_not_starts_with: String
  data_ends_with: String
  data_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  platformId: Int
  platformId_not: Int
  platformId_in: [Int!]
  platformId_not_in: [Int!]
  platformId_lt: Int
  platformId_lte: Int
  platformId_gt: Int
  platformId_gte: Int
  udate: DateTime
  udate_not: DateTime
  udate_in: [DateTime!]
  udate_not_in: [DateTime!]
  udate_lt: DateTime
  udate_lte: DateTime
  udate_gt: DateTime
  udate_gte: DateTime
  AND: [PlatformSessionWhereInput!]
  OR: [PlatformSessionWhereInput!]
  NOT: [PlatformSessionWhereInput!]
}

input PlatformSessionWhereUniqueInput {
  sess_id: Int
}

type Query {
  conceptDatum(where: ConceptDatumWhereUniqueInput!): ConceptDatum
  conceptData(where: ConceptDatumWhereInput, orderBy: ConceptDatumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ConceptDatum]!
  conceptDataConnection(where: ConceptDatumWhereInput, orderBy: ConceptDatumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConceptDatumConnection!
  infoDemandTest(where: InfoDemandTestWhereUniqueInput!): InfoDemandTest
  infoDemandTests(where: InfoDemandTestWhereInput, orderBy: InfoDemandTestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InfoDemandTest]!
  infoDemandTestsConnection(where: InfoDemandTestWhereInput, orderBy: InfoDemandTestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InfoDemandTestConnection!
  informationDemand(where: InformationDemandWhereUniqueInput!): InformationDemand
  informationDemands(where: InformationDemandWhereInput, orderBy: InformationDemandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InformationDemand]!
  informationDemandsConnection(where: InformationDemandWhereInput, orderBy: InformationDemandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InformationDemandConnection!
  platformMarketPrice(where: PlatformMarketPriceWhereUniqueInput!): PlatformMarketPrice
  platformMarketPrices(where: PlatformMarketPriceWhereInput, orderBy: PlatformMarketPriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PlatformMarketPrice]!
  platformMarketPricesConnection(where: PlatformMarketPriceWhereInput, orderBy: PlatformMarketPriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlatformMarketPriceConnection!
  platformSession(where: PlatformSessionWhereUniqueInput!): PlatformSession
  platformSessions(where: PlatformSessionWhereInput, orderBy: PlatformSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PlatformSession]!
  platformSessionsConnection(where: PlatformSessionWhereInput, orderBy: PlatformSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlatformSessionConnection!
  requestType(where: RequestTypeWhereUniqueInput!): RequestType
  requestTypes(where: RequestTypeWhereInput, orderBy: RequestTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RequestType]!
  requestTypesConnection(where: RequestTypeWhereInput, orderBy: RequestTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RequestTypeConnection!
  test(where: TestWhereUniqueInput!): Test
  tests(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Test]!
  testsConnection(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type RequestType {
  id: Int!
  requestType: String!
  requestValue: String!
}

type RequestTypeConnection {
  pageInfo: PageInfo!
  edges: [RequestTypeEdge]!
  aggregate: AggregateRequestType!
}

input RequestTypeCreateInput {
  id: Int
  requestType: String!
  requestValue: String!
}

type RequestTypeEdge {
  node: RequestType!
  cursor: String!
}

enum RequestTypeOrderByInput {
  id_ASC
  id_DESC
  requestType_ASC
  requestType_DESC
  requestValue_ASC
  requestValue_DESC
}

type RequestTypePreviousValues {
  id: Int!
  requestType: String!
  requestValue: String!
}

type RequestTypeSubscriptionPayload {
  mutation: MutationType!
  node: RequestType
  updatedFields: [String!]
  previousValues: RequestTypePreviousValues
}

input RequestTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RequestTypeWhereInput
  AND: [RequestTypeSubscriptionWhereInput!]
  OR: [RequestTypeSubscriptionWhereInput!]
  NOT: [RequestTypeSubscriptionWhereInput!]
}

input RequestTypeUpdateInput {
  requestType: String
  requestValue: String
}

input RequestTypeUpdateManyMutationInput {
  requestType: String
  requestValue: String
}

input RequestTypeWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  requestType: String
  requestType_not: String
  requestType_in: [String!]
  requestType_not_in: [String!]
  requestType_lt: String
  requestType_lte: String
  requestType_gt: String
  requestType_gte: String
  requestType_contains: String
  requestType_not_contains: String
  requestType_starts_with: String
  requestType_not_starts_with: String
  requestType_ends_with: String
  requestType_not_ends_with: String
  requestValue: String
  requestValue_not: String
  requestValue_in: [String!]
  requestValue_not_in: [String!]
  requestValue_lt: String
  requestValue_lte: String
  requestValue_gt: String
  requestValue_gte: String
  requestValue_contains: String
  requestValue_not_contains: String
  requestValue_starts_with: String
  requestValue_not_starts_with: String
  requestValue_ends_with: String
  requestValue_not_ends_with: String
  AND: [RequestTypeWhereInput!]
  OR: [RequestTypeWhereInput!]
  NOT: [RequestTypeWhereInput!]
}

input RequestTypeWhereUniqueInput {
  id: Int
}

type Subscription {
  conceptDatum(where: ConceptDatumSubscriptionWhereInput): ConceptDatumSubscriptionPayload
  infoDemandTest(where: InfoDemandTestSubscriptionWhereInput): InfoDemandTestSubscriptionPayload
  informationDemand(where: InformationDemandSubscriptionWhereInput): InformationDemandSubscriptionPayload
  platformMarketPrice(where: PlatformMarketPriceSubscriptionWhereInput): PlatformMarketPriceSubscriptionPayload
  platformSession(where: PlatformSessionSubscriptionWhereInput): PlatformSessionSubscriptionPayload
  requestType(where: RequestTypeSubscriptionWhereInput): RequestTypeSubscriptionPayload
  test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Test {
  id: Int
  platformSessionId: Int
  requestId: Int
  userId: Int
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge]!
  aggregate: AggregateTest!
}

input TestCreateInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

type TestEdge {
  node: Test!
  cursor: String!
}

enum TestOrderByInput {
  id_ASC
  id_DESC
  platformSessionId_ASC
  platformSessionId_DESC
  requestId_ASC
  requestId_DESC
  userId_ASC
  userId_DESC
}

type TestPreviousValues {
  id: Int
  platformSessionId: Int
  requestId: Int
  userId: Int
}

type TestSubscriptionPayload {
  mutation: MutationType!
  node: Test
  updatedFields: [String!]
  previousValues: TestPreviousValues
}

input TestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestWhereInput
  AND: [TestSubscriptionWhereInput!]
  OR: [TestSubscriptionWhereInput!]
  NOT: [TestSubscriptionWhereInput!]
}

input TestUpdateInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

input TestUpdateManyMutationInput {
  platformSessionId: Int
  requestId: Int
  userId: Int
}

input TestWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  platformSessionId: Int
  platformSessionId_not: Int
  platformSessionId_in: [Int!]
  platformSessionId_not_in: [Int!]
  platformSessionId_lt: Int
  platformSessionId_lte: Int
  platformSessionId_gt: Int
  platformSessionId_gte: Int
  requestId: Int
  requestId_not: Int
  requestId_in: [Int!]
  requestId_not_in: [Int!]
  requestId_lt: Int
  requestId_lte: Int
  requestId_gt: Int
  requestId_gte: Int
  userId: Int
  userId_not: Int
  userId_in: [Int!]
  userId_not_in: [Int!]
  userId_lt: Int
  userId_lte: Int
  userId_gt: Int
  userId_gte: Int
  AND: [TestWhereInput!]
  OR: [TestWhereInput!]
  NOT: [TestWhereInput!]
}

input TestWhereUniqueInput {
  id: Int
}

type User {
  id: Int!
  age: String
  cellNum: String
  countryOfResidence: String
  crossingFreq: String
  education: String
  gender: String
  language: String
  primaryIncome: String
  produce: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: Int
  age: String
  cellNum: String
  countryOfResidence: String
  crossingFreq: String
  education: String
  gender: String
  language: String
  primaryIncome: String
  produce: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  age_ASC
  age_DESC
  cellNum_ASC
  cellNum_DESC
  countryOfResidence_ASC
  countryOfResidence_DESC
  crossingFreq_ASC
  crossingFreq_DESC
  education_ASC
  education_DESC
  gender_ASC
  gender_DESC
  language_ASC
  language_DESC
  primaryIncome_ASC
  primaryIncome_DESC
  produce_ASC
  produce_DESC
}

type UserPreviousValues {
  id: Int!
  age: String
  cellNum: String
  countryOfResidence: String
  crossingFreq: String
  education: String
  gender: String
  language: String
  primaryIncome: String
  produce: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  age: String
  cellNum: String
  countryOfResidence: String
  crossingFreq: String
  education: String
  gender: String
  language: String
  primaryIncome: String
  produce: String
}

input UserUpdateManyMutationInput {
  age: String
  cellNum: String
  countryOfResidence: String
  crossingFreq: String
  education: String
  gender: String
  language: String
  primaryIncome: String
  produce: String
}

input UserWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  age: String
  age_not: String
  age_in: [String!]
  age_not_in: [String!]
  age_lt: String
  age_lte: String
  age_gt: String
  age_gte: String
  age_contains: String
  age_not_contains: String
  age_starts_with: String
  age_not_starts_with: String
  age_ends_with: String
  age_not_ends_with: String
  cellNum: String
  cellNum_not: String
  cellNum_in: [String!]
  cellNum_not_in: [String!]
  cellNum_lt: String
  cellNum_lte: String
  cellNum_gt: String
  cellNum_gte: String
  cellNum_contains: String
  cellNum_not_contains: String
  cellNum_starts_with: String
  cellNum_not_starts_with: String
  cellNum_ends_with: String
  cellNum_not_ends_with: String
  countryOfResidence: String
  countryOfResidence_not: String
  countryOfResidence_in: [String!]
  countryOfResidence_not_in: [String!]
  countryOfResidence_lt: String
  countryOfResidence_lte: String
  countryOfResidence_gt: String
  countryOfResidence_gte: String
  countryOfResidence_contains: String
  countryOfResidence_not_contains: String
  countryOfResidence_starts_with: String
  countryOfResidence_not_starts_with: String
  countryOfResidence_ends_with: String
  countryOfResidence_not_ends_with: String
  crossingFreq: String
  crossingFreq_not: String
  crossingFreq_in: [String!]
  crossingFreq_not_in: [String!]
  crossingFreq_lt: String
  crossingFreq_lte: String
  crossingFreq_gt: String
  crossingFreq_gte: String
  crossingFreq_contains: String
  crossingFreq_not_contains: String
  crossingFreq_starts_with: String
  crossingFreq_not_starts_with: String
  crossingFreq_ends_with: String
  crossingFreq_not_ends_with: String
  education: String
  education_not: String
  education_in: [String!]
  education_not_in: [String!]
  education_lt: String
  education_lte: String
  education_gt: String
  education_gte: String
  education_contains: String
  education_not_contains: String
  education_starts_with: String
  education_not_starts_with: String
  education_ends_with: String
  education_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  primaryIncome: String
  primaryIncome_not: String
  primaryIncome_in: [String!]
  primaryIncome_not_in: [String!]
  primaryIncome_lt: String
  primaryIncome_lte: String
  primaryIncome_gt: String
  primaryIncome_gte: String
  primaryIncome_contains: String
  primaryIncome_not_contains: String
  primaryIncome_starts_with: String
  primaryIncome_not_starts_with: String
  primaryIncome_ends_with: String
  primaryIncome_not_ends_with: String
  produce: String
  produce_not: String
  produce_in: [String!]
  produce_not_in: [String!]
  produce_lt: String
  produce_lte: String
  produce_gt: String
  produce_gte: String
  produce_contains: String
  produce_not_contains: String
  produce_starts_with: String
  produce_not_starts_with: String
  produce_ends_with: String
  produce_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: Int
}
`
      }
    