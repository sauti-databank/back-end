// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  conceptDatum: (where?: ConceptDatumWhereInput) => Promise<boolean>;
  infoDemandTest: (where?: InfoDemandTestWhereInput) => Promise<boolean>;
  informationDemand: (where?: InformationDemandWhereInput) => Promise<boolean>;
  platformMarketPrice: (
    where?: PlatformMarketPriceWhereInput
  ) => Promise<boolean>;
  platformSession: (where?: PlatformSessionWhereInput) => Promise<boolean>;
  requestType: (where?: RequestTypeWhereInput) => Promise<boolean>;
  test: (where?: TestWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  conceptDatum: (
    where: ConceptDatumWhereUniqueInput
  ) => ConceptDatumNullablePromise;
  conceptData: (args?: {
    where?: ConceptDatumWhereInput;
    orderBy?: ConceptDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ConceptDatum>;
  conceptDataConnection: (args?: {
    where?: ConceptDatumWhereInput;
    orderBy?: ConceptDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConceptDatumConnectionPromise;
  infoDemandTest: (
    where: InfoDemandTestWhereUniqueInput
  ) => InfoDemandTestNullablePromise;
  infoDemandTests: (args?: {
    where?: InfoDemandTestWhereInput;
    orderBy?: InfoDemandTestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InfoDemandTest>;
  infoDemandTestsConnection: (args?: {
    where?: InfoDemandTestWhereInput;
    orderBy?: InfoDemandTestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InfoDemandTestConnectionPromise;
  informationDemand: (
    where: InformationDemandWhereUniqueInput
  ) => InformationDemandNullablePromise;
  informationDemands: (args?: {
    where?: InformationDemandWhereInput;
    orderBy?: InformationDemandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InformationDemand>;
  informationDemandsConnection: (args?: {
    where?: InformationDemandWhereInput;
    orderBy?: InformationDemandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InformationDemandConnectionPromise;
  platformMarketPrice: (
    where: PlatformMarketPriceWhereUniqueInput
  ) => PlatformMarketPriceNullablePromise;
  platformMarketPrices: (args?: {
    where?: PlatformMarketPriceWhereInput;
    orderBy?: PlatformMarketPriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlatformMarketPrice>;
  platformMarketPricesConnection: (args?: {
    where?: PlatformMarketPriceWhereInput;
    orderBy?: PlatformMarketPriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlatformMarketPriceConnectionPromise;
  platformSession: (
    where: PlatformSessionWhereUniqueInput
  ) => PlatformSessionNullablePromise;
  platformSessions: (args?: {
    where?: PlatformSessionWhereInput;
    orderBy?: PlatformSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlatformSession>;
  platformSessionsConnection: (args?: {
    where?: PlatformSessionWhereInput;
    orderBy?: PlatformSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlatformSessionConnectionPromise;
  requestType: (
    where: RequestTypeWhereUniqueInput
  ) => RequestTypeNullablePromise;
  requestTypes: (args?: {
    where?: RequestTypeWhereInput;
    orderBy?: RequestTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RequestType>;
  requestTypesConnection: (args?: {
    where?: RequestTypeWhereInput;
    orderBy?: RequestTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequestTypeConnectionPromise;
  test: (where: TestWhereUniqueInput) => TestNullablePromise;
  tests: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Test>;
  testsConnection: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createConceptDatum: (data: ConceptDatumCreateInput) => ConceptDatumPromise;
  updateConceptDatum: (args: {
    data: ConceptDatumUpdateInput;
    where: ConceptDatumWhereUniqueInput;
  }) => ConceptDatumPromise;
  updateManyConceptData: (args: {
    data: ConceptDatumUpdateManyMutationInput;
    where?: ConceptDatumWhereInput;
  }) => BatchPayloadPromise;
  upsertConceptDatum: (args: {
    where: ConceptDatumWhereUniqueInput;
    create: ConceptDatumCreateInput;
    update: ConceptDatumUpdateInput;
  }) => ConceptDatumPromise;
  deleteConceptDatum: (
    where: ConceptDatumWhereUniqueInput
  ) => ConceptDatumPromise;
  deleteManyConceptData: (
    where?: ConceptDatumWhereInput
  ) => BatchPayloadPromise;
  createInfoDemandTest: (
    data: InfoDemandTestCreateInput
  ) => InfoDemandTestPromise;
  updateInfoDemandTest: (args: {
    data: InfoDemandTestUpdateInput;
    where: InfoDemandTestWhereUniqueInput;
  }) => InfoDemandTestPromise;
  updateManyInfoDemandTests: (args: {
    data: InfoDemandTestUpdateManyMutationInput;
    where?: InfoDemandTestWhereInput;
  }) => BatchPayloadPromise;
  upsertInfoDemandTest: (args: {
    where: InfoDemandTestWhereUniqueInput;
    create: InfoDemandTestCreateInput;
    update: InfoDemandTestUpdateInput;
  }) => InfoDemandTestPromise;
  deleteInfoDemandTest: (
    where: InfoDemandTestWhereUniqueInput
  ) => InfoDemandTestPromise;
  deleteManyInfoDemandTests: (
    where?: InfoDemandTestWhereInput
  ) => BatchPayloadPromise;
  createInformationDemand: (
    data: InformationDemandCreateInput
  ) => InformationDemandPromise;
  updateInformationDemand: (args: {
    data: InformationDemandUpdateInput;
    where: InformationDemandWhereUniqueInput;
  }) => InformationDemandPromise;
  updateManyInformationDemands: (args: {
    data: InformationDemandUpdateManyMutationInput;
    where?: InformationDemandWhereInput;
  }) => BatchPayloadPromise;
  upsertInformationDemand: (args: {
    where: InformationDemandWhereUniqueInput;
    create: InformationDemandCreateInput;
    update: InformationDemandUpdateInput;
  }) => InformationDemandPromise;
  deleteInformationDemand: (
    where: InformationDemandWhereUniqueInput
  ) => InformationDemandPromise;
  deleteManyInformationDemands: (
    where?: InformationDemandWhereInput
  ) => BatchPayloadPromise;
  createPlatformMarketPrice: (
    data: PlatformMarketPriceCreateInput
  ) => PlatformMarketPricePromise;
  updatePlatformMarketPrice: (args: {
    data: PlatformMarketPriceUpdateInput;
    where: PlatformMarketPriceWhereUniqueInput;
  }) => PlatformMarketPricePromise;
  updateManyPlatformMarketPrices: (args: {
    data: PlatformMarketPriceUpdateManyMutationInput;
    where?: PlatformMarketPriceWhereInput;
  }) => BatchPayloadPromise;
  upsertPlatformMarketPrice: (args: {
    where: PlatformMarketPriceWhereUniqueInput;
    create: PlatformMarketPriceCreateInput;
    update: PlatformMarketPriceUpdateInput;
  }) => PlatformMarketPricePromise;
  deletePlatformMarketPrice: (
    where: PlatformMarketPriceWhereUniqueInput
  ) => PlatformMarketPricePromise;
  deleteManyPlatformMarketPrices: (
    where?: PlatformMarketPriceWhereInput
  ) => BatchPayloadPromise;
  createPlatformSession: (
    data: PlatformSessionCreateInput
  ) => PlatformSessionPromise;
  updatePlatformSession: (args: {
    data: PlatformSessionUpdateInput;
    where: PlatformSessionWhereUniqueInput;
  }) => PlatformSessionPromise;
  updateManyPlatformSessions: (args: {
    data: PlatformSessionUpdateManyMutationInput;
    where?: PlatformSessionWhereInput;
  }) => BatchPayloadPromise;
  upsertPlatformSession: (args: {
    where: PlatformSessionWhereUniqueInput;
    create: PlatformSessionCreateInput;
    update: PlatformSessionUpdateInput;
  }) => PlatformSessionPromise;
  deletePlatformSession: (
    where: PlatformSessionWhereUniqueInput
  ) => PlatformSessionPromise;
  deleteManyPlatformSessions: (
    where?: PlatformSessionWhereInput
  ) => BatchPayloadPromise;
  createRequestType: (data: RequestTypeCreateInput) => RequestTypePromise;
  updateRequestType: (args: {
    data: RequestTypeUpdateInput;
    where: RequestTypeWhereUniqueInput;
  }) => RequestTypePromise;
  updateManyRequestTypes: (args: {
    data: RequestTypeUpdateManyMutationInput;
    where?: RequestTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertRequestType: (args: {
    where: RequestTypeWhereUniqueInput;
    create: RequestTypeCreateInput;
    update: RequestTypeUpdateInput;
  }) => RequestTypePromise;
  deleteRequestType: (where: RequestTypeWhereUniqueInput) => RequestTypePromise;
  deleteManyRequestTypes: (
    where?: RequestTypeWhereInput
  ) => BatchPayloadPromise;
  createTest: (data: TestCreateInput) => TestPromise;
  updateTest: (args: {
    data: TestUpdateInput;
    where: TestWhereUniqueInput;
  }) => TestPromise;
  updateManyTests: (args: {
    data: TestUpdateManyMutationInput;
    where?: TestWhereInput;
  }) => BatchPayloadPromise;
  upsertTest: (args: {
    where: TestWhereUniqueInput;
    create: TestCreateInput;
    update: TestUpdateInput;
  }) => TestPromise;
  deleteTest: (where: TestWhereUniqueInput) => TestPromise;
  deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  conceptDatum: (
    where?: ConceptDatumSubscriptionWhereInput
  ) => ConceptDatumSubscriptionPayloadSubscription;
  infoDemandTest: (
    where?: InfoDemandTestSubscriptionWhereInput
  ) => InfoDemandTestSubscriptionPayloadSubscription;
  informationDemand: (
    where?: InformationDemandSubscriptionWhereInput
  ) => InformationDemandSubscriptionPayloadSubscription;
  platformMarketPrice: (
    where?: PlatformMarketPriceSubscriptionWhereInput
  ) => PlatformMarketPriceSubscriptionPayloadSubscription;
  platformSession: (
    where?: PlatformSessionSubscriptionWhereInput
  ) => PlatformSessionSubscriptionPayloadSubscription;
  requestType: (
    where?: RequestTypeSubscriptionWhereInput
  ) => RequestTypeSubscriptionPayloadSubscription;
  test: (
    where?: TestSubscriptionWhereInput
  ) => TestSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ConceptDatumOrderByInput =
  | "data_id_ASC"
  | "data_id_DESC"
  | "cellNum_ASC"
  | "cellNum_DESC"
  | "dataKey_ASC"
  | "dataKey_DESC"
  | "dataValue_ASC"
  | "dataValue_DESC";

export type InfoDemandTestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "platformSessionId_ASC"
  | "platformSessionId_DESC"
  | "requestId_ASC"
  | "requestId_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type InformationDemandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "platformSessionId_ASC"
  | "platformSessionId_DESC"
  | "requestId_ASC"
  | "requestId_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type PlatformMarketPriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "active_ASC"
  | "active_DESC"
  | "country_ASC"
  | "country_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "date_ASC"
  | "date_DESC"
  | "market_ASC"
  | "market_DESC"
  | "product_ASC"
  | "product_DESC"
  | "productAgg_ASC"
  | "productAgg_DESC"
  | "productCat_ASC"
  | "productCat_DESC"
  | "retail_ASC"
  | "retail_DESC"
  | "source_ASC"
  | "source_DESC"
  | "udate_ASC"
  | "udate_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "wholesale_ASC"
  | "wholesale_DESC";

export type PlatformSessionOrderByInput =
  | "sess_id_ASC"
  | "sess_id_DESC"
  | "cellNum_ASC"
  | "cellNum_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC"
  | "data_ASC"
  | "data_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "platformId_ASC"
  | "platformId_DESC"
  | "udate_ASC"
  | "udate_DESC";

export type RequestTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "requestType_ASC"
  | "requestType_DESC"
  | "requestValue_ASC"
  | "requestValue_DESC";

export type TestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "platformSessionId_ASC"
  | "platformSessionId_DESC"
  | "requestId_ASC"
  | "requestId_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "age_ASC"
  | "age_DESC"
  | "cellNum_ASC"
  | "cellNum_DESC"
  | "countryOfResidence_ASC"
  | "countryOfResidence_DESC"
  | "crossingFreq_ASC"
  | "crossingFreq_DESC"
  | "education_ASC"
  | "education_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "language_ASC"
  | "language_DESC"
  | "primaryIncome_ASC"
  | "primaryIncome_DESC"
  | "produce_ASC"
  | "produce_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ConceptDatumWhereUniqueInput = AtLeastOne<{
  data_id: Maybe<Int>;
}>;

export interface ConceptDatumWhereInput {
  data_id?: Maybe<Int>;
  data_id_not?: Maybe<Int>;
  data_id_in?: Maybe<Int[] | Int>;
  data_id_not_in?: Maybe<Int[] | Int>;
  data_id_lt?: Maybe<Int>;
  data_id_lte?: Maybe<Int>;
  data_id_gt?: Maybe<Int>;
  data_id_gte?: Maybe<Int>;
  cellNum?: Maybe<String>;
  cellNum_not?: Maybe<String>;
  cellNum_in?: Maybe<String[] | String>;
  cellNum_not_in?: Maybe<String[] | String>;
  cellNum_lt?: Maybe<String>;
  cellNum_lte?: Maybe<String>;
  cellNum_gt?: Maybe<String>;
  cellNum_gte?: Maybe<String>;
  cellNum_contains?: Maybe<String>;
  cellNum_not_contains?: Maybe<String>;
  cellNum_starts_with?: Maybe<String>;
  cellNum_not_starts_with?: Maybe<String>;
  cellNum_ends_with?: Maybe<String>;
  cellNum_not_ends_with?: Maybe<String>;
  dataKey?: Maybe<String>;
  dataKey_not?: Maybe<String>;
  dataKey_in?: Maybe<String[] | String>;
  dataKey_not_in?: Maybe<String[] | String>;
  dataKey_lt?: Maybe<String>;
  dataKey_lte?: Maybe<String>;
  dataKey_gt?: Maybe<String>;
  dataKey_gte?: Maybe<String>;
  dataKey_contains?: Maybe<String>;
  dataKey_not_contains?: Maybe<String>;
  dataKey_starts_with?: Maybe<String>;
  dataKey_not_starts_with?: Maybe<String>;
  dataKey_ends_with?: Maybe<String>;
  dataKey_not_ends_with?: Maybe<String>;
  dataValue?: Maybe<String>;
  dataValue_not?: Maybe<String>;
  dataValue_in?: Maybe<String[] | String>;
  dataValue_not_in?: Maybe<String[] | String>;
  dataValue_lt?: Maybe<String>;
  dataValue_lte?: Maybe<String>;
  dataValue_gt?: Maybe<String>;
  dataValue_gte?: Maybe<String>;
  dataValue_contains?: Maybe<String>;
  dataValue_not_contains?: Maybe<String>;
  dataValue_starts_with?: Maybe<String>;
  dataValue_not_starts_with?: Maybe<String>;
  dataValue_ends_with?: Maybe<String>;
  dataValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<ConceptDatumWhereInput[] | ConceptDatumWhereInput>;
  OR?: Maybe<ConceptDatumWhereInput[] | ConceptDatumWhereInput>;
  NOT?: Maybe<ConceptDatumWhereInput[] | ConceptDatumWhereInput>;
}

export type InfoDemandTestWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface InfoDemandTestWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  platformSessionId?: Maybe<Int>;
  platformSessionId_not?: Maybe<Int>;
  platformSessionId_in?: Maybe<Int[] | Int>;
  platformSessionId_not_in?: Maybe<Int[] | Int>;
  platformSessionId_lt?: Maybe<Int>;
  platformSessionId_lte?: Maybe<Int>;
  platformSessionId_gt?: Maybe<Int>;
  platformSessionId_gte?: Maybe<Int>;
  requestId?: Maybe<Int>;
  requestId_not?: Maybe<Int>;
  requestId_in?: Maybe<Int[] | Int>;
  requestId_not_in?: Maybe<Int[] | Int>;
  requestId_lt?: Maybe<Int>;
  requestId_lte?: Maybe<Int>;
  requestId_gt?: Maybe<Int>;
  requestId_gte?: Maybe<Int>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  AND?: Maybe<InfoDemandTestWhereInput[] | InfoDemandTestWhereInput>;
  OR?: Maybe<InfoDemandTestWhereInput[] | InfoDemandTestWhereInput>;
  NOT?: Maybe<InfoDemandTestWhereInput[] | InfoDemandTestWhereInput>;
}

export type InformationDemandWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface InformationDemandWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  platformSessionId?: Maybe<Int>;
  platformSessionId_not?: Maybe<Int>;
  platformSessionId_in?: Maybe<Int[] | Int>;
  platformSessionId_not_in?: Maybe<Int[] | Int>;
  platformSessionId_lt?: Maybe<Int>;
  platformSessionId_lte?: Maybe<Int>;
  platformSessionId_gt?: Maybe<Int>;
  platformSessionId_gte?: Maybe<Int>;
  requestId?: Maybe<Int>;
  requestId_not?: Maybe<Int>;
  requestId_in?: Maybe<Int[] | Int>;
  requestId_not_in?: Maybe<Int[] | Int>;
  requestId_lt?: Maybe<Int>;
  requestId_lte?: Maybe<Int>;
  requestId_gt?: Maybe<Int>;
  requestId_gte?: Maybe<Int>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  AND?: Maybe<InformationDemandWhereInput[] | InformationDemandWhereInput>;
  OR?: Maybe<InformationDemandWhereInput[] | InformationDemandWhereInput>;
  NOT?: Maybe<InformationDemandWhereInput[] | InformationDemandWhereInput>;
}

export type PlatformMarketPriceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface PlatformMarketPriceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  currency?: Maybe<String>;
  currency_not?: Maybe<String>;
  currency_in?: Maybe<String[] | String>;
  currency_not_in?: Maybe<String[] | String>;
  currency_lt?: Maybe<String>;
  currency_lte?: Maybe<String>;
  currency_gt?: Maybe<String>;
  currency_gte?: Maybe<String>;
  currency_contains?: Maybe<String>;
  currency_not_contains?: Maybe<String>;
  currency_starts_with?: Maybe<String>;
  currency_not_starts_with?: Maybe<String>;
  currency_ends_with?: Maybe<String>;
  currency_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  market?: Maybe<String>;
  market_not?: Maybe<String>;
  market_in?: Maybe<String[] | String>;
  market_not_in?: Maybe<String[] | String>;
  market_lt?: Maybe<String>;
  market_lte?: Maybe<String>;
  market_gt?: Maybe<String>;
  market_gte?: Maybe<String>;
  market_contains?: Maybe<String>;
  market_not_contains?: Maybe<String>;
  market_starts_with?: Maybe<String>;
  market_not_starts_with?: Maybe<String>;
  market_ends_with?: Maybe<String>;
  market_not_ends_with?: Maybe<String>;
  product?: Maybe<String>;
  product_not?: Maybe<String>;
  product_in?: Maybe<String[] | String>;
  product_not_in?: Maybe<String[] | String>;
  product_lt?: Maybe<String>;
  product_lte?: Maybe<String>;
  product_gt?: Maybe<String>;
  product_gte?: Maybe<String>;
  product_contains?: Maybe<String>;
  product_not_contains?: Maybe<String>;
  product_starts_with?: Maybe<String>;
  product_not_starts_with?: Maybe<String>;
  product_ends_with?: Maybe<String>;
  product_not_ends_with?: Maybe<String>;
  productAgg?: Maybe<String>;
  productAgg_not?: Maybe<String>;
  productAgg_in?: Maybe<String[] | String>;
  productAgg_not_in?: Maybe<String[] | String>;
  productAgg_lt?: Maybe<String>;
  productAgg_lte?: Maybe<String>;
  productAgg_gt?: Maybe<String>;
  productAgg_gte?: Maybe<String>;
  productAgg_contains?: Maybe<String>;
  productAgg_not_contains?: Maybe<String>;
  productAgg_starts_with?: Maybe<String>;
  productAgg_not_starts_with?: Maybe<String>;
  productAgg_ends_with?: Maybe<String>;
  productAgg_not_ends_with?: Maybe<String>;
  productCat?: Maybe<String>;
  productCat_not?: Maybe<String>;
  productCat_in?: Maybe<String[] | String>;
  productCat_not_in?: Maybe<String[] | String>;
  productCat_lt?: Maybe<String>;
  productCat_lte?: Maybe<String>;
  productCat_gt?: Maybe<String>;
  productCat_gte?: Maybe<String>;
  productCat_contains?: Maybe<String>;
  productCat_not_contains?: Maybe<String>;
  productCat_starts_with?: Maybe<String>;
  productCat_not_starts_with?: Maybe<String>;
  productCat_ends_with?: Maybe<String>;
  productCat_not_ends_with?: Maybe<String>;
  retail?: Maybe<Int>;
  retail_not?: Maybe<Int>;
  retail_in?: Maybe<Int[] | Int>;
  retail_not_in?: Maybe<Int[] | Int>;
  retail_lt?: Maybe<Int>;
  retail_lte?: Maybe<Int>;
  retail_gt?: Maybe<Int>;
  retail_gte?: Maybe<Int>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  udate?: Maybe<DateTimeInput>;
  udate_not?: Maybe<DateTimeInput>;
  udate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  udate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  udate_lt?: Maybe<DateTimeInput>;
  udate_lte?: Maybe<DateTimeInput>;
  udate_gt?: Maybe<DateTimeInput>;
  udate_gte?: Maybe<DateTimeInput>;
  unit?: Maybe<String>;
  unit_not?: Maybe<String>;
  unit_in?: Maybe<String[] | String>;
  unit_not_in?: Maybe<String[] | String>;
  unit_lt?: Maybe<String>;
  unit_lte?: Maybe<String>;
  unit_gt?: Maybe<String>;
  unit_gte?: Maybe<String>;
  unit_contains?: Maybe<String>;
  unit_not_contains?: Maybe<String>;
  unit_starts_with?: Maybe<String>;
  unit_not_starts_with?: Maybe<String>;
  unit_ends_with?: Maybe<String>;
  unit_not_ends_with?: Maybe<String>;
  wholesale?: Maybe<Int>;
  wholesale_not?: Maybe<Int>;
  wholesale_in?: Maybe<Int[] | Int>;
  wholesale_not_in?: Maybe<Int[] | Int>;
  wholesale_lt?: Maybe<Int>;
  wholesale_lte?: Maybe<Int>;
  wholesale_gt?: Maybe<Int>;
  wholesale_gte?: Maybe<Int>;
  AND?: Maybe<PlatformMarketPriceWhereInput[] | PlatformMarketPriceWhereInput>;
  OR?: Maybe<PlatformMarketPriceWhereInput[] | PlatformMarketPriceWhereInput>;
  NOT?: Maybe<PlatformMarketPriceWhereInput[] | PlatformMarketPriceWhereInput>;
}

export type PlatformSessionWhereUniqueInput = AtLeastOne<{
  sess_id: Maybe<Int>;
}>;

export interface PlatformSessionWhereInput {
  sess_id?: Maybe<Int>;
  sess_id_not?: Maybe<Int>;
  sess_id_in?: Maybe<Int[] | Int>;
  sess_id_not_in?: Maybe<Int[] | Int>;
  sess_id_lt?: Maybe<Int>;
  sess_id_lte?: Maybe<Int>;
  sess_id_gt?: Maybe<Int>;
  sess_id_gte?: Maybe<Int>;
  cellNum?: Maybe<String>;
  cellNum_not?: Maybe<String>;
  cellNum_in?: Maybe<String[] | String>;
  cellNum_not_in?: Maybe<String[] | String>;
  cellNum_lt?: Maybe<String>;
  cellNum_lte?: Maybe<String>;
  cellNum_gt?: Maybe<String>;
  cellNum_gte?: Maybe<String>;
  cellNum_contains?: Maybe<String>;
  cellNum_not_contains?: Maybe<String>;
  cellNum_starts_with?: Maybe<String>;
  cellNum_not_starts_with?: Maybe<String>;
  cellNum_ends_with?: Maybe<String>;
  cellNum_not_ends_with?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  data?: Maybe<String>;
  data_not?: Maybe<String>;
  data_in?: Maybe<String[] | String>;
  data_not_in?: Maybe<String[] | String>;
  data_lt?: Maybe<String>;
  data_lte?: Maybe<String>;
  data_gt?: Maybe<String>;
  data_gte?: Maybe<String>;
  data_contains?: Maybe<String>;
  data_not_contains?: Maybe<String>;
  data_starts_with?: Maybe<String>;
  data_not_starts_with?: Maybe<String>;
  data_ends_with?: Maybe<String>;
  data_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  platformId?: Maybe<Int>;
  platformId_not?: Maybe<Int>;
  platformId_in?: Maybe<Int[] | Int>;
  platformId_not_in?: Maybe<Int[] | Int>;
  platformId_lt?: Maybe<Int>;
  platformId_lte?: Maybe<Int>;
  platformId_gt?: Maybe<Int>;
  platformId_gte?: Maybe<Int>;
  udate?: Maybe<DateTimeInput>;
  udate_not?: Maybe<DateTimeInput>;
  udate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  udate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  udate_lt?: Maybe<DateTimeInput>;
  udate_lte?: Maybe<DateTimeInput>;
  udate_gt?: Maybe<DateTimeInput>;
  udate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlatformSessionWhereInput[] | PlatformSessionWhereInput>;
  OR?: Maybe<PlatformSessionWhereInput[] | PlatformSessionWhereInput>;
  NOT?: Maybe<PlatformSessionWhereInput[] | PlatformSessionWhereInput>;
}

export type RequestTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface RequestTypeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  requestType?: Maybe<String>;
  requestType_not?: Maybe<String>;
  requestType_in?: Maybe<String[] | String>;
  requestType_not_in?: Maybe<String[] | String>;
  requestType_lt?: Maybe<String>;
  requestType_lte?: Maybe<String>;
  requestType_gt?: Maybe<String>;
  requestType_gte?: Maybe<String>;
  requestType_contains?: Maybe<String>;
  requestType_not_contains?: Maybe<String>;
  requestType_starts_with?: Maybe<String>;
  requestType_not_starts_with?: Maybe<String>;
  requestType_ends_with?: Maybe<String>;
  requestType_not_ends_with?: Maybe<String>;
  requestValue?: Maybe<String>;
  requestValue_not?: Maybe<String>;
  requestValue_in?: Maybe<String[] | String>;
  requestValue_not_in?: Maybe<String[] | String>;
  requestValue_lt?: Maybe<String>;
  requestValue_lte?: Maybe<String>;
  requestValue_gt?: Maybe<String>;
  requestValue_gte?: Maybe<String>;
  requestValue_contains?: Maybe<String>;
  requestValue_not_contains?: Maybe<String>;
  requestValue_starts_with?: Maybe<String>;
  requestValue_not_starts_with?: Maybe<String>;
  requestValue_ends_with?: Maybe<String>;
  requestValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<RequestTypeWhereInput[] | RequestTypeWhereInput>;
  OR?: Maybe<RequestTypeWhereInput[] | RequestTypeWhereInput>;
  NOT?: Maybe<RequestTypeWhereInput[] | RequestTypeWhereInput>;
}

export type TestWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface TestWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  platformSessionId?: Maybe<Int>;
  platformSessionId_not?: Maybe<Int>;
  platformSessionId_in?: Maybe<Int[] | Int>;
  platformSessionId_not_in?: Maybe<Int[] | Int>;
  platformSessionId_lt?: Maybe<Int>;
  platformSessionId_lte?: Maybe<Int>;
  platformSessionId_gt?: Maybe<Int>;
  platformSessionId_gte?: Maybe<Int>;
  requestId?: Maybe<Int>;
  requestId_not?: Maybe<Int>;
  requestId_in?: Maybe<Int[] | Int>;
  requestId_not_in?: Maybe<Int[] | Int>;
  requestId_lt?: Maybe<Int>;
  requestId_lte?: Maybe<Int>;
  requestId_gt?: Maybe<Int>;
  requestId_gte?: Maybe<Int>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  AND?: Maybe<TestWhereInput[] | TestWhereInput>;
  OR?: Maybe<TestWhereInput[] | TestWhereInput>;
  NOT?: Maybe<TestWhereInput[] | TestWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface UserWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  age?: Maybe<String>;
  age_not?: Maybe<String>;
  age_in?: Maybe<String[] | String>;
  age_not_in?: Maybe<String[] | String>;
  age_lt?: Maybe<String>;
  age_lte?: Maybe<String>;
  age_gt?: Maybe<String>;
  age_gte?: Maybe<String>;
  age_contains?: Maybe<String>;
  age_not_contains?: Maybe<String>;
  age_starts_with?: Maybe<String>;
  age_not_starts_with?: Maybe<String>;
  age_ends_with?: Maybe<String>;
  age_not_ends_with?: Maybe<String>;
  cellNum?: Maybe<String>;
  cellNum_not?: Maybe<String>;
  cellNum_in?: Maybe<String[] | String>;
  cellNum_not_in?: Maybe<String[] | String>;
  cellNum_lt?: Maybe<String>;
  cellNum_lte?: Maybe<String>;
  cellNum_gt?: Maybe<String>;
  cellNum_gte?: Maybe<String>;
  cellNum_contains?: Maybe<String>;
  cellNum_not_contains?: Maybe<String>;
  cellNum_starts_with?: Maybe<String>;
  cellNum_not_starts_with?: Maybe<String>;
  cellNum_ends_with?: Maybe<String>;
  cellNum_not_ends_with?: Maybe<String>;
  countryOfResidence?: Maybe<String>;
  countryOfResidence_not?: Maybe<String>;
  countryOfResidence_in?: Maybe<String[] | String>;
  countryOfResidence_not_in?: Maybe<String[] | String>;
  countryOfResidence_lt?: Maybe<String>;
  countryOfResidence_lte?: Maybe<String>;
  countryOfResidence_gt?: Maybe<String>;
  countryOfResidence_gte?: Maybe<String>;
  countryOfResidence_contains?: Maybe<String>;
  countryOfResidence_not_contains?: Maybe<String>;
  countryOfResidence_starts_with?: Maybe<String>;
  countryOfResidence_not_starts_with?: Maybe<String>;
  countryOfResidence_ends_with?: Maybe<String>;
  countryOfResidence_not_ends_with?: Maybe<String>;
  crossingFreq?: Maybe<String>;
  crossingFreq_not?: Maybe<String>;
  crossingFreq_in?: Maybe<String[] | String>;
  crossingFreq_not_in?: Maybe<String[] | String>;
  crossingFreq_lt?: Maybe<String>;
  crossingFreq_lte?: Maybe<String>;
  crossingFreq_gt?: Maybe<String>;
  crossingFreq_gte?: Maybe<String>;
  crossingFreq_contains?: Maybe<String>;
  crossingFreq_not_contains?: Maybe<String>;
  crossingFreq_starts_with?: Maybe<String>;
  crossingFreq_not_starts_with?: Maybe<String>;
  crossingFreq_ends_with?: Maybe<String>;
  crossingFreq_not_ends_with?: Maybe<String>;
  education?: Maybe<String>;
  education_not?: Maybe<String>;
  education_in?: Maybe<String[] | String>;
  education_not_in?: Maybe<String[] | String>;
  education_lt?: Maybe<String>;
  education_lte?: Maybe<String>;
  education_gt?: Maybe<String>;
  education_gte?: Maybe<String>;
  education_contains?: Maybe<String>;
  education_not_contains?: Maybe<String>;
  education_starts_with?: Maybe<String>;
  education_not_starts_with?: Maybe<String>;
  education_ends_with?: Maybe<String>;
  education_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  language?: Maybe<String>;
  language_not?: Maybe<String>;
  language_in?: Maybe<String[] | String>;
  language_not_in?: Maybe<String[] | String>;
  language_lt?: Maybe<String>;
  language_lte?: Maybe<String>;
  language_gt?: Maybe<String>;
  language_gte?: Maybe<String>;
  language_contains?: Maybe<String>;
  language_not_contains?: Maybe<String>;
  language_starts_with?: Maybe<String>;
  language_not_starts_with?: Maybe<String>;
  language_ends_with?: Maybe<String>;
  language_not_ends_with?: Maybe<String>;
  primaryIncome?: Maybe<String>;
  primaryIncome_not?: Maybe<String>;
  primaryIncome_in?: Maybe<String[] | String>;
  primaryIncome_not_in?: Maybe<String[] | String>;
  primaryIncome_lt?: Maybe<String>;
  primaryIncome_lte?: Maybe<String>;
  primaryIncome_gt?: Maybe<String>;
  primaryIncome_gte?: Maybe<String>;
  primaryIncome_contains?: Maybe<String>;
  primaryIncome_not_contains?: Maybe<String>;
  primaryIncome_starts_with?: Maybe<String>;
  primaryIncome_not_starts_with?: Maybe<String>;
  primaryIncome_ends_with?: Maybe<String>;
  primaryIncome_not_ends_with?: Maybe<String>;
  produce?: Maybe<String>;
  produce_not?: Maybe<String>;
  produce_in?: Maybe<String[] | String>;
  produce_not_in?: Maybe<String[] | String>;
  produce_lt?: Maybe<String>;
  produce_lte?: Maybe<String>;
  produce_gt?: Maybe<String>;
  produce_gte?: Maybe<String>;
  produce_contains?: Maybe<String>;
  produce_not_contains?: Maybe<String>;
  produce_starts_with?: Maybe<String>;
  produce_not_starts_with?: Maybe<String>;
  produce_ends_with?: Maybe<String>;
  produce_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ConceptDatumCreateInput {
  data_id?: Maybe<Int>;
  cellNum: String;
  dataKey: String;
  dataValue: String;
}

export interface ConceptDatumUpdateInput {
  cellNum?: Maybe<String>;
  dataKey?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface ConceptDatumUpdateManyMutationInput {
  cellNum?: Maybe<String>;
  dataKey?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface InfoDemandTestCreateInput {
  id?: Maybe<Int>;
  platformSessionId: Int;
  requestId: Int;
  userId: Int;
}

export interface InfoDemandTestUpdateInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface InfoDemandTestUpdateManyMutationInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface InformationDemandCreateInput {
  id?: Maybe<Int>;
  platformSessionId: Int;
  requestId: Int;
  userId: Int;
}

export interface InformationDemandUpdateInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface InformationDemandUpdateManyMutationInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface PlatformMarketPriceCreateInput {
  id?: Maybe<Int>;
  active?: Maybe<Boolean>;
  country: String;
  currency: String;
  date: DateTimeInput;
  market: String;
  product: String;
  productAgg: String;
  productCat: String;
  retail: Int;
  source: String;
  udate?: Maybe<DateTimeInput>;
  unit: String;
  wholesale: Int;
}

export interface PlatformMarketPriceUpdateInput {
  active?: Maybe<Boolean>;
  country?: Maybe<String>;
  currency?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  market?: Maybe<String>;
  product?: Maybe<String>;
  productAgg?: Maybe<String>;
  productCat?: Maybe<String>;
  retail?: Maybe<Int>;
  source?: Maybe<String>;
  udate?: Maybe<DateTimeInput>;
  unit?: Maybe<String>;
  wholesale?: Maybe<Int>;
}

export interface PlatformMarketPriceUpdateManyMutationInput {
  active?: Maybe<Boolean>;
  country?: Maybe<String>;
  currency?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  market?: Maybe<String>;
  product?: Maybe<String>;
  productAgg?: Maybe<String>;
  productCat?: Maybe<String>;
  retail?: Maybe<Int>;
  source?: Maybe<String>;
  udate?: Maybe<DateTimeInput>;
  unit?: Maybe<String>;
  wholesale?: Maybe<Int>;
}

export interface PlatformSessionCreateInput {
  sess_id?: Maybe<Int>;
  cellNum: String;
  createdDate: DateTimeInput;
  data: String;
  notes: String;
  platformId?: Maybe<Int>;
  udate?: Maybe<DateTimeInput>;
}

export interface PlatformSessionUpdateInput {
  cellNum?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  data?: Maybe<String>;
  notes?: Maybe<String>;
  platformId?: Maybe<Int>;
  udate?: Maybe<DateTimeInput>;
}

export interface PlatformSessionUpdateManyMutationInput {
  cellNum?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  data?: Maybe<String>;
  notes?: Maybe<String>;
  platformId?: Maybe<Int>;
  udate?: Maybe<DateTimeInput>;
}

export interface RequestTypeCreateInput {
  id?: Maybe<Int>;
  requestType: String;
  requestValue: String;
}

export interface RequestTypeUpdateInput {
  requestType?: Maybe<String>;
  requestValue?: Maybe<String>;
}

export interface RequestTypeUpdateManyMutationInput {
  requestType?: Maybe<String>;
  requestValue?: Maybe<String>;
}

export interface TestCreateInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface TestUpdateInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface TestUpdateManyMutationInput {
  platformSessionId?: Maybe<Int>;
  requestId?: Maybe<Int>;
  userId?: Maybe<Int>;
}

export interface UserCreateInput {
  id?: Maybe<Int>;
  age?: Maybe<String>;
  cellNum?: Maybe<String>;
  countryOfResidence?: Maybe<String>;
  crossingFreq?: Maybe<String>;
  education?: Maybe<String>;
  gender?: Maybe<String>;
  language?: Maybe<String>;
  primaryIncome?: Maybe<String>;
  produce?: Maybe<String>;
}

export interface UserUpdateInput {
  age?: Maybe<String>;
  cellNum?: Maybe<String>;
  countryOfResidence?: Maybe<String>;
  crossingFreq?: Maybe<String>;
  education?: Maybe<String>;
  gender?: Maybe<String>;
  language?: Maybe<String>;
  primaryIncome?: Maybe<String>;
  produce?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  age?: Maybe<String>;
  cellNum?: Maybe<String>;
  countryOfResidence?: Maybe<String>;
  crossingFreq?: Maybe<String>;
  education?: Maybe<String>;
  gender?: Maybe<String>;
  language?: Maybe<String>;
  primaryIncome?: Maybe<String>;
  produce?: Maybe<String>;
}

export interface ConceptDatumSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConceptDatumWhereInput>;
  AND?: Maybe<
    ConceptDatumSubscriptionWhereInput[] | ConceptDatumSubscriptionWhereInput
  >;
  OR?: Maybe<
    ConceptDatumSubscriptionWhereInput[] | ConceptDatumSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ConceptDatumSubscriptionWhereInput[] | ConceptDatumSubscriptionWhereInput
  >;
}

export interface InfoDemandTestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InfoDemandTestWhereInput>;
  AND?: Maybe<
    | InfoDemandTestSubscriptionWhereInput[]
    | InfoDemandTestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | InfoDemandTestSubscriptionWhereInput[]
    | InfoDemandTestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InfoDemandTestSubscriptionWhereInput[]
    | InfoDemandTestSubscriptionWhereInput
  >;
}

export interface InformationDemandSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InformationDemandWhereInput>;
  AND?: Maybe<
    | InformationDemandSubscriptionWhereInput[]
    | InformationDemandSubscriptionWhereInput
  >;
  OR?: Maybe<
    | InformationDemandSubscriptionWhereInput[]
    | InformationDemandSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InformationDemandSubscriptionWhereInput[]
    | InformationDemandSubscriptionWhereInput
  >;
}

export interface PlatformMarketPriceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlatformMarketPriceWhereInput>;
  AND?: Maybe<
    | PlatformMarketPriceSubscriptionWhereInput[]
    | PlatformMarketPriceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PlatformMarketPriceSubscriptionWhereInput[]
    | PlatformMarketPriceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PlatformMarketPriceSubscriptionWhereInput[]
    | PlatformMarketPriceSubscriptionWhereInput
  >;
}

export interface PlatformSessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlatformSessionWhereInput>;
  AND?: Maybe<
    | PlatformSessionSubscriptionWhereInput[]
    | PlatformSessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PlatformSessionSubscriptionWhereInput[]
    | PlatformSessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PlatformSessionSubscriptionWhereInput[]
    | PlatformSessionSubscriptionWhereInput
  >;
}

export interface RequestTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequestTypeWhereInput>;
  AND?: Maybe<
    RequestTypeSubscriptionWhereInput[] | RequestTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    RequestTypeSubscriptionWhereInput[] | RequestTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RequestTypeSubscriptionWhereInput[] | RequestTypeSubscriptionWhereInput
  >;
}

export interface TestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TestWhereInput>;
  AND?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
  OR?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
  NOT?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ConceptDatum {
  data_id: Int;
  cellNum: String;
  dataKey: String;
  dataValue: String;
}

export interface ConceptDatumPromise
  extends Promise<ConceptDatum>,
    Fragmentable {
  data_id: () => Promise<Int>;
  cellNum: () => Promise<String>;
  dataKey: () => Promise<String>;
  dataValue: () => Promise<String>;
}

export interface ConceptDatumSubscription
  extends Promise<AsyncIterator<ConceptDatum>>,
    Fragmentable {
  data_id: () => Promise<AsyncIterator<Int>>;
  cellNum: () => Promise<AsyncIterator<String>>;
  dataKey: () => Promise<AsyncIterator<String>>;
  dataValue: () => Promise<AsyncIterator<String>>;
}

export interface ConceptDatumNullablePromise
  extends Promise<ConceptDatum | null>,
    Fragmentable {
  data_id: () => Promise<Int>;
  cellNum: () => Promise<String>;
  dataKey: () => Promise<String>;
  dataValue: () => Promise<String>;
}

export interface ConceptDatumConnection {
  pageInfo: PageInfo;
  edges: ConceptDatumEdge[];
}

export interface ConceptDatumConnectionPromise
  extends Promise<ConceptDatumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConceptDatumEdge>>() => T;
  aggregate: <T = AggregateConceptDatumPromise>() => T;
}

export interface ConceptDatumConnectionSubscription
  extends Promise<AsyncIterator<ConceptDatumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConceptDatumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConceptDatumSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ConceptDatumEdge {
  node: ConceptDatum;
  cursor: String;
}

export interface ConceptDatumEdgePromise
  extends Promise<ConceptDatumEdge>,
    Fragmentable {
  node: <T = ConceptDatumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConceptDatumEdgeSubscription
  extends Promise<AsyncIterator<ConceptDatumEdge>>,
    Fragmentable {
  node: <T = ConceptDatumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateConceptDatum {
  count: Int;
}

export interface AggregateConceptDatumPromise
  extends Promise<AggregateConceptDatum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConceptDatumSubscription
  extends Promise<AsyncIterator<AggregateConceptDatum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InfoDemandTest {
  id: Int;
  platformSessionId: Int;
  requestId: Int;
  userId: Int;
}

export interface InfoDemandTestPromise
  extends Promise<InfoDemandTest>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface InfoDemandTestSubscription
  extends Promise<AsyncIterator<InfoDemandTest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  platformSessionId: () => Promise<AsyncIterator<Int>>;
  requestId: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface InfoDemandTestNullablePromise
  extends Promise<InfoDemandTest | null>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface InfoDemandTestConnection {
  pageInfo: PageInfo;
  edges: InfoDemandTestEdge[];
}

export interface InfoDemandTestConnectionPromise
  extends Promise<InfoDemandTestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InfoDemandTestEdge>>() => T;
  aggregate: <T = AggregateInfoDemandTestPromise>() => T;
}

export interface InfoDemandTestConnectionSubscription
  extends Promise<AsyncIterator<InfoDemandTestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InfoDemandTestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInfoDemandTestSubscription>() => T;
}

export interface InfoDemandTestEdge {
  node: InfoDemandTest;
  cursor: String;
}

export interface InfoDemandTestEdgePromise
  extends Promise<InfoDemandTestEdge>,
    Fragmentable {
  node: <T = InfoDemandTestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InfoDemandTestEdgeSubscription
  extends Promise<AsyncIterator<InfoDemandTestEdge>>,
    Fragmentable {
  node: <T = InfoDemandTestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInfoDemandTest {
  count: Int;
}

export interface AggregateInfoDemandTestPromise
  extends Promise<AggregateInfoDemandTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInfoDemandTestSubscription
  extends Promise<AsyncIterator<AggregateInfoDemandTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InformationDemand {
  id: Int;
  platformSessionId: Int;
  requestId: Int;
  userId: Int;
}

export interface InformationDemandPromise
  extends Promise<InformationDemand>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface InformationDemandSubscription
  extends Promise<AsyncIterator<InformationDemand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  platformSessionId: () => Promise<AsyncIterator<Int>>;
  requestId: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface InformationDemandNullablePromise
  extends Promise<InformationDemand | null>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface InformationDemandConnection {
  pageInfo: PageInfo;
  edges: InformationDemandEdge[];
}

export interface InformationDemandConnectionPromise
  extends Promise<InformationDemandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InformationDemandEdge>>() => T;
  aggregate: <T = AggregateInformationDemandPromise>() => T;
}

export interface InformationDemandConnectionSubscription
  extends Promise<AsyncIterator<InformationDemandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InformationDemandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInformationDemandSubscription>() => T;
}

export interface InformationDemandEdge {
  node: InformationDemand;
  cursor: String;
}

export interface InformationDemandEdgePromise
  extends Promise<InformationDemandEdge>,
    Fragmentable {
  node: <T = InformationDemandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InformationDemandEdgeSubscription
  extends Promise<AsyncIterator<InformationDemandEdge>>,
    Fragmentable {
  node: <T = InformationDemandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInformationDemand {
  count: Int;
}

export interface AggregateInformationDemandPromise
  extends Promise<AggregateInformationDemand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInformationDemandSubscription
  extends Promise<AsyncIterator<AggregateInformationDemand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformMarketPrice {
  id: Int;
  active: Boolean;
  country: String;
  currency: String;
  date: DateTimeOutput;
  market: String;
  product: String;
  productAgg: String;
  productCat: String;
  retail: Int;
  source: String;
  udate: DateTimeOutput;
  unit: String;
  wholesale: Int;
}

export interface PlatformMarketPricePromise
  extends Promise<PlatformMarketPrice>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  country: () => Promise<String>;
  currency: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  market: () => Promise<String>;
  product: () => Promise<String>;
  productAgg: () => Promise<String>;
  productCat: () => Promise<String>;
  retail: () => Promise<Int>;
  source: () => Promise<String>;
  udate: () => Promise<DateTimeOutput>;
  unit: () => Promise<String>;
  wholesale: () => Promise<Int>;
}

export interface PlatformMarketPriceSubscription
  extends Promise<AsyncIterator<PlatformMarketPrice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  country: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  market: () => Promise<AsyncIterator<String>>;
  product: () => Promise<AsyncIterator<String>>;
  productAgg: () => Promise<AsyncIterator<String>>;
  productCat: () => Promise<AsyncIterator<String>>;
  retail: () => Promise<AsyncIterator<Int>>;
  source: () => Promise<AsyncIterator<String>>;
  udate: () => Promise<AsyncIterator<DateTimeOutput>>;
  unit: () => Promise<AsyncIterator<String>>;
  wholesale: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformMarketPriceNullablePromise
  extends Promise<PlatformMarketPrice | null>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  country: () => Promise<String>;
  currency: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  market: () => Promise<String>;
  product: () => Promise<String>;
  productAgg: () => Promise<String>;
  productCat: () => Promise<String>;
  retail: () => Promise<Int>;
  source: () => Promise<String>;
  udate: () => Promise<DateTimeOutput>;
  unit: () => Promise<String>;
  wholesale: () => Promise<Int>;
}

export interface PlatformMarketPriceConnection {
  pageInfo: PageInfo;
  edges: PlatformMarketPriceEdge[];
}

export interface PlatformMarketPriceConnectionPromise
  extends Promise<PlatformMarketPriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlatformMarketPriceEdge>>() => T;
  aggregate: <T = AggregatePlatformMarketPricePromise>() => T;
}

export interface PlatformMarketPriceConnectionSubscription
  extends Promise<AsyncIterator<PlatformMarketPriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PlatformMarketPriceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePlatformMarketPriceSubscription>() => T;
}

export interface PlatformMarketPriceEdge {
  node: PlatformMarketPrice;
  cursor: String;
}

export interface PlatformMarketPriceEdgePromise
  extends Promise<PlatformMarketPriceEdge>,
    Fragmentable {
  node: <T = PlatformMarketPricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlatformMarketPriceEdgeSubscription
  extends Promise<AsyncIterator<PlatformMarketPriceEdge>>,
    Fragmentable {
  node: <T = PlatformMarketPriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlatformMarketPrice {
  count: Int;
}

export interface AggregatePlatformMarketPricePromise
  extends Promise<AggregatePlatformMarketPrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlatformMarketPriceSubscription
  extends Promise<AsyncIterator<AggregatePlatformMarketPrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformSession {
  sess_id: Int;
  cellNum: String;
  createdDate: DateTimeOutput;
  data: String;
  notes: String;
  platformId?: Int;
  udate: DateTimeOutput;
}

export interface PlatformSessionPromise
  extends Promise<PlatformSession>,
    Fragmentable {
  sess_id: () => Promise<Int>;
  cellNum: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  data: () => Promise<String>;
  notes: () => Promise<String>;
  platformId: () => Promise<Int>;
  udate: () => Promise<DateTimeOutput>;
}

export interface PlatformSessionSubscription
  extends Promise<AsyncIterator<PlatformSession>>,
    Fragmentable {
  sess_id: () => Promise<AsyncIterator<Int>>;
  cellNum: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  data: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  platformId: () => Promise<AsyncIterator<Int>>;
  udate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlatformSessionNullablePromise
  extends Promise<PlatformSession | null>,
    Fragmentable {
  sess_id: () => Promise<Int>;
  cellNum: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  data: () => Promise<String>;
  notes: () => Promise<String>;
  platformId: () => Promise<Int>;
  udate: () => Promise<DateTimeOutput>;
}

export interface PlatformSessionConnection {
  pageInfo: PageInfo;
  edges: PlatformSessionEdge[];
}

export interface PlatformSessionConnectionPromise
  extends Promise<PlatformSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlatformSessionEdge>>() => T;
  aggregate: <T = AggregatePlatformSessionPromise>() => T;
}

export interface PlatformSessionConnectionSubscription
  extends Promise<AsyncIterator<PlatformSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlatformSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlatformSessionSubscription>() => T;
}

export interface PlatformSessionEdge {
  node: PlatformSession;
  cursor: String;
}

export interface PlatformSessionEdgePromise
  extends Promise<PlatformSessionEdge>,
    Fragmentable {
  node: <T = PlatformSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlatformSessionEdgeSubscription
  extends Promise<AsyncIterator<PlatformSessionEdge>>,
    Fragmentable {
  node: <T = PlatformSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlatformSession {
  count: Int;
}

export interface AggregatePlatformSessionPromise
  extends Promise<AggregatePlatformSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlatformSessionSubscription
  extends Promise<AsyncIterator<AggregatePlatformSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RequestType {
  id: Int;
  requestType: String;
  requestValue: String;
}

export interface RequestTypePromise extends Promise<RequestType>, Fragmentable {
  id: () => Promise<Int>;
  requestType: () => Promise<String>;
  requestValue: () => Promise<String>;
}

export interface RequestTypeSubscription
  extends Promise<AsyncIterator<RequestType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  requestType: () => Promise<AsyncIterator<String>>;
  requestValue: () => Promise<AsyncIterator<String>>;
}

export interface RequestTypeNullablePromise
  extends Promise<RequestType | null>,
    Fragmentable {
  id: () => Promise<Int>;
  requestType: () => Promise<String>;
  requestValue: () => Promise<String>;
}

export interface RequestTypeConnection {
  pageInfo: PageInfo;
  edges: RequestTypeEdge[];
}

export interface RequestTypeConnectionPromise
  extends Promise<RequestTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequestTypeEdge>>() => T;
  aggregate: <T = AggregateRequestTypePromise>() => T;
}

export interface RequestTypeConnectionSubscription
  extends Promise<AsyncIterator<RequestTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequestTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequestTypeSubscription>() => T;
}

export interface RequestTypeEdge {
  node: RequestType;
  cursor: String;
}

export interface RequestTypeEdgePromise
  extends Promise<RequestTypeEdge>,
    Fragmentable {
  node: <T = RequestTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequestTypeEdgeSubscription
  extends Promise<AsyncIterator<RequestTypeEdge>>,
    Fragmentable {
  node: <T = RequestTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRequestType {
  count: Int;
}

export interface AggregateRequestTypePromise
  extends Promise<AggregateRequestType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequestTypeSubscription
  extends Promise<AsyncIterator<AggregateRequestType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Test {
  id?: Int;
  platformSessionId?: Int;
  requestId?: Int;
  userId?: Int;
}

export interface TestPromise extends Promise<Test>, Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface TestSubscription
  extends Promise<AsyncIterator<Test>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  platformSessionId: () => Promise<AsyncIterator<Int>>;
  requestId: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface TestNullablePromise
  extends Promise<Test | null>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface TestConnection {
  pageInfo: PageInfo;
  edges: TestEdge[];
}

export interface TestConnectionPromise
  extends Promise<TestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestEdge>>() => T;
  aggregate: <T = AggregateTestPromise>() => T;
}

export interface TestConnectionSubscription
  extends Promise<AsyncIterator<TestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestSubscription>() => T;
}

export interface TestEdge {
  node: Test;
  cursor: String;
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
  node: <T = TestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestEdgeSubscription
  extends Promise<AsyncIterator<TestEdge>>,
    Fragmentable {
  node: <T = TestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTest {
  count: Int;
}

export interface AggregateTestPromise
  extends Promise<AggregateTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestSubscription
  extends Promise<AsyncIterator<AggregateTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: Int;
  age?: String;
  cellNum?: String;
  countryOfResidence?: String;
  crossingFreq?: String;
  education?: String;
  gender?: String;
  language?: String;
  primaryIncome?: String;
  produce?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  age: () => Promise<String>;
  cellNum: () => Promise<String>;
  countryOfResidence: () => Promise<String>;
  crossingFreq: () => Promise<String>;
  education: () => Promise<String>;
  gender: () => Promise<String>;
  language: () => Promise<String>;
  primaryIncome: () => Promise<String>;
  produce: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  age: () => Promise<AsyncIterator<String>>;
  cellNum: () => Promise<AsyncIterator<String>>;
  countryOfResidence: () => Promise<AsyncIterator<String>>;
  crossingFreq: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  primaryIncome: () => Promise<AsyncIterator<String>>;
  produce: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<Int>;
  age: () => Promise<String>;
  cellNum: () => Promise<String>;
  countryOfResidence: () => Promise<String>;
  crossingFreq: () => Promise<String>;
  education: () => Promise<String>;
  gender: () => Promise<String>;
  language: () => Promise<String>;
  primaryIncome: () => Promise<String>;
  produce: () => Promise<String>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ConceptDatumSubscriptionPayload {
  mutation: MutationType;
  node: ConceptDatum;
  updatedFields: String[];
  previousValues: ConceptDatumPreviousValues;
}

export interface ConceptDatumSubscriptionPayloadPromise
  extends Promise<ConceptDatumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConceptDatumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConceptDatumPreviousValuesPromise>() => T;
}

export interface ConceptDatumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConceptDatumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConceptDatumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConceptDatumPreviousValuesSubscription>() => T;
}

export interface ConceptDatumPreviousValues {
  data_id: Int;
  cellNum: String;
  dataKey: String;
  dataValue: String;
}

export interface ConceptDatumPreviousValuesPromise
  extends Promise<ConceptDatumPreviousValues>,
    Fragmentable {
  data_id: () => Promise<Int>;
  cellNum: () => Promise<String>;
  dataKey: () => Promise<String>;
  dataValue: () => Promise<String>;
}

export interface ConceptDatumPreviousValuesSubscription
  extends Promise<AsyncIterator<ConceptDatumPreviousValues>>,
    Fragmentable {
  data_id: () => Promise<AsyncIterator<Int>>;
  cellNum: () => Promise<AsyncIterator<String>>;
  dataKey: () => Promise<AsyncIterator<String>>;
  dataValue: () => Promise<AsyncIterator<String>>;
}

export interface InfoDemandTestSubscriptionPayload {
  mutation: MutationType;
  node: InfoDemandTest;
  updatedFields: String[];
  previousValues: InfoDemandTestPreviousValues;
}

export interface InfoDemandTestSubscriptionPayloadPromise
  extends Promise<InfoDemandTestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InfoDemandTestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InfoDemandTestPreviousValuesPromise>() => T;
}

export interface InfoDemandTestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InfoDemandTestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InfoDemandTestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InfoDemandTestPreviousValuesSubscription>() => T;
}

export interface InfoDemandTestPreviousValues {
  id: Int;
  platformSessionId: Int;
  requestId: Int;
  userId: Int;
}

export interface InfoDemandTestPreviousValuesPromise
  extends Promise<InfoDemandTestPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface InfoDemandTestPreviousValuesSubscription
  extends Promise<AsyncIterator<InfoDemandTestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  platformSessionId: () => Promise<AsyncIterator<Int>>;
  requestId: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface InformationDemandSubscriptionPayload {
  mutation: MutationType;
  node: InformationDemand;
  updatedFields: String[];
  previousValues: InformationDemandPreviousValues;
}

export interface InformationDemandSubscriptionPayloadPromise
  extends Promise<InformationDemandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InformationDemandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InformationDemandPreviousValuesPromise>() => T;
}

export interface InformationDemandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InformationDemandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InformationDemandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InformationDemandPreviousValuesSubscription>() => T;
}

export interface InformationDemandPreviousValues {
  id: Int;
  platformSessionId: Int;
  requestId: Int;
  userId: Int;
}

export interface InformationDemandPreviousValuesPromise
  extends Promise<InformationDemandPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface InformationDemandPreviousValuesSubscription
  extends Promise<AsyncIterator<InformationDemandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  platformSessionId: () => Promise<AsyncIterator<Int>>;
  requestId: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformMarketPriceSubscriptionPayload {
  mutation: MutationType;
  node: PlatformMarketPrice;
  updatedFields: String[];
  previousValues: PlatformMarketPricePreviousValues;
}

export interface PlatformMarketPriceSubscriptionPayloadPromise
  extends Promise<PlatformMarketPriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlatformMarketPricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlatformMarketPricePreviousValuesPromise>() => T;
}

export interface PlatformMarketPriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlatformMarketPriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlatformMarketPriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlatformMarketPricePreviousValuesSubscription>() => T;
}

export interface PlatformMarketPricePreviousValues {
  id: Int;
  active: Boolean;
  country: String;
  currency: String;
  date: DateTimeOutput;
  market: String;
  product: String;
  productAgg: String;
  productCat: String;
  retail: Int;
  source: String;
  udate: DateTimeOutput;
  unit: String;
  wholesale: Int;
}

export interface PlatformMarketPricePreviousValuesPromise
  extends Promise<PlatformMarketPricePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  active: () => Promise<Boolean>;
  country: () => Promise<String>;
  currency: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  market: () => Promise<String>;
  product: () => Promise<String>;
  productAgg: () => Promise<String>;
  productCat: () => Promise<String>;
  retail: () => Promise<Int>;
  source: () => Promise<String>;
  udate: () => Promise<DateTimeOutput>;
  unit: () => Promise<String>;
  wholesale: () => Promise<Int>;
}

export interface PlatformMarketPricePreviousValuesSubscription
  extends Promise<AsyncIterator<PlatformMarketPricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  country: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  market: () => Promise<AsyncIterator<String>>;
  product: () => Promise<AsyncIterator<String>>;
  productAgg: () => Promise<AsyncIterator<String>>;
  productCat: () => Promise<AsyncIterator<String>>;
  retail: () => Promise<AsyncIterator<Int>>;
  source: () => Promise<AsyncIterator<String>>;
  udate: () => Promise<AsyncIterator<DateTimeOutput>>;
  unit: () => Promise<AsyncIterator<String>>;
  wholesale: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformSessionSubscriptionPayload {
  mutation: MutationType;
  node: PlatformSession;
  updatedFields: String[];
  previousValues: PlatformSessionPreviousValues;
}

export interface PlatformSessionSubscriptionPayloadPromise
  extends Promise<PlatformSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlatformSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlatformSessionPreviousValuesPromise>() => T;
}

export interface PlatformSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlatformSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlatformSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlatformSessionPreviousValuesSubscription>() => T;
}

export interface PlatformSessionPreviousValues {
  sess_id: Int;
  cellNum: String;
  createdDate: DateTimeOutput;
  data: String;
  notes: String;
  platformId?: Int;
  udate: DateTimeOutput;
}

export interface PlatformSessionPreviousValuesPromise
  extends Promise<PlatformSessionPreviousValues>,
    Fragmentable {
  sess_id: () => Promise<Int>;
  cellNum: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  data: () => Promise<String>;
  notes: () => Promise<String>;
  platformId: () => Promise<Int>;
  udate: () => Promise<DateTimeOutput>;
}

export interface PlatformSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<PlatformSessionPreviousValues>>,
    Fragmentable {
  sess_id: () => Promise<AsyncIterator<Int>>;
  cellNum: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  data: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  platformId: () => Promise<AsyncIterator<Int>>;
  udate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RequestTypeSubscriptionPayload {
  mutation: MutationType;
  node: RequestType;
  updatedFields: String[];
  previousValues: RequestTypePreviousValues;
}

export interface RequestTypeSubscriptionPayloadPromise
  extends Promise<RequestTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequestTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequestTypePreviousValuesPromise>() => T;
}

export interface RequestTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequestTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequestTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequestTypePreviousValuesSubscription>() => T;
}

export interface RequestTypePreviousValues {
  id: Int;
  requestType: String;
  requestValue: String;
}

export interface RequestTypePreviousValuesPromise
  extends Promise<RequestTypePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  requestType: () => Promise<String>;
  requestValue: () => Promise<String>;
}

export interface RequestTypePreviousValuesSubscription
  extends Promise<AsyncIterator<RequestTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  requestType: () => Promise<AsyncIterator<String>>;
  requestValue: () => Promise<AsyncIterator<String>>;
}

export interface TestSubscriptionPayload {
  mutation: MutationType;
  node: Test;
  updatedFields: String[];
  previousValues: TestPreviousValues;
}

export interface TestSubscriptionPayloadPromise
  extends Promise<TestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestPreviousValuesPromise>() => T;
}

export interface TestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestPreviousValuesSubscription>() => T;
}

export interface TestPreviousValues {
  id?: Int;
  platformSessionId?: Int;
  requestId?: Int;
  userId?: Int;
}

export interface TestPreviousValuesPromise
  extends Promise<TestPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  platformSessionId: () => Promise<Int>;
  requestId: () => Promise<Int>;
  userId: () => Promise<Int>;
}

export interface TestPreviousValuesSubscription
  extends Promise<AsyncIterator<TestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  platformSessionId: () => Promise<AsyncIterator<Int>>;
  requestId: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: Int;
  age?: String;
  cellNum?: String;
  countryOfResidence?: String;
  crossingFreq?: String;
  education?: String;
  gender?: String;
  language?: String;
  primaryIncome?: String;
  produce?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  age: () => Promise<String>;
  cellNum: () => Promise<String>;
  countryOfResidence: () => Promise<String>;
  crossingFreq: () => Promise<String>;
  education: () => Promise<String>;
  gender: () => Promise<String>;
  language: () => Promise<String>;
  primaryIncome: () => Promise<String>;
  produce: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  age: () => Promise<AsyncIterator<String>>;
  cellNum: () => Promise<AsyncIterator<String>>;
  countryOfResidence: () => Promise<AsyncIterator<String>>;
  crossingFreq: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  primaryIncome: () => Promise<AsyncIterator<String>>;
  produce: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ConceptDatum",
    embedded: false
  },
  {
    name: "InfoDemandTest",
    embedded: false
  },
  {
    name: "InformationDemand",
    embedded: false
  },
  {
    name: "PlatformMarketPrice",
    embedded: false
  },
  {
    name: "PlatformSession",
    embedded: false
  },
  {
    name: "RequestType",
    embedded: false
  },
  {
    name: "Test",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
